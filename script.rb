require 'rubygems'
require 'logger'
require 'rugged'
require 'git'

# Include diff, difffile classes
load 'diff.rb'
load 'difffile.rb'
load 'helper.rb'

# Global array to store all the diffs
diffs_array = []

# Initialize both libraries
working_dir = `pwd`.chomp
rubygit_gem_repo = Git.open(working_dir, :log => Logger.new(STDOUT))
rugged_repo = Rugged::Repository.new(working_dir)

# Get all the commits for the project
commit_list = rubygit_gem_repo.log(nil)

# Get the initial empty tree state
empty_tree=`git hash-object -t tree /dev/null`
empty_state = rugged_repo.lookup("#{empty_tree.chomp}")

commit_list_array = commit_list.to_a
commit_list_array.reverse!
commit_list_array.insert(0, empty_state)

num_commits = commit_list_array.size
for i in 0...num_commits-1
  prev_commit = commit_list_array[i]
  next_commit = commit_list_array[i+1]
  # Special handling for empty-tree state, as it'e generated by Rugged.
  # SO, there is no sha field, rather an oid field
  if prev_commit.respond_to?("sha")
    prev_sha = prev_commit.sha
  else
    prev_sha = prev_commit.oid
  end

  next_sha = next_commit.sha
  diff_bw_commits = rubygit_gem_repo.diff(prev_sha, next_sha)

  diff = Diff.new(prev_sha, next_sha, diff_bw_commits)
  diff.generate_difffiles_and_stats
  diffs_array << diff
end

puts commit_list_array.count
puts diffs_array.count

DEBUG_LOGGER(diffs_array)
# # Find the diff between the empty tree and the first commit
# diff = beg.diff(commit_object)
#
# # Get patch for the diff
# patch = diff.patch
#
# # Get delta (faster, if you only need information on what files changed)
# diff.each_delta{ |d| puts d.inspect }
#
# # Number of deltas i.e. count of files changed
# diff.deltas.count
#
# # To easily parse the diff and store patch diff for each file
# # use
# #g.diff(commit1, commit2).size
# #g.diff(commit1, commit2).stats
# # at https://github.com/schacon/ruby-git

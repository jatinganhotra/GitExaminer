require 'rubygems'
require 'logger'
require 'rugged'
require 'git'
require 'awesome_print'

# Include diff, difffile classes
load 'diff.rb'
load 'difffile.rb'
load 'helper.rb'
load 'debug_helper.rb'

# Global array to store all the diffs
diffs_array = []

# Initialize both libraries
git_repo_path = ARGV[0]
rubygit_gem_repo = Git.open(git_repo_path, :log => Logger.new(STDOUT))
rugged_repo = Rugged::Repository.new(git_repo_path)

# Get all the commits for the project
commit_list = rubygit_gem_repo.log(nil)
commit_list_array = commit_list.to_a
commit_list_array.reverse!

# ----------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------

# FIXME: Somehow this always gives errors. Get the initial empty tree state
#empty_tree=`git hash-object -w -t tree /dev/null`
#empty_state = rugged_repo.lookup("#{empty_tree.chomp}")
#commit_list_array.insert(0, empty_state)

# FIXME: Change this line to find reverts only in a subset of commits
num_commits = commit_list_array.size
target_history_count = (ARGV[1].nil? == false) ? ARGV[1] : num_commits - 1

for i in 0...target_history_count
  prev_commit = commit_list_array[i]
  next_commit = commit_list_array[i+1]

  # Special handling for empty-tree state, as it's generated by Rugged API
  # So, there is no SHA field, rather an OID field
  prev_sha = ( prev_commit.respond_to?("sha") ) ? prev_commit.sha : prev_commit.oid
  next_sha = next_commit.sha

  # Using the ruby-git gem for diff between commits
  diff_bw_commits = rubygit_gem_repo.diff(prev_sha, next_sha)

  # FIXME: Can use Rugged gem for calculating diffs
  # rugged_prev_commit = rugged_repo.lookup(prev_sha)
  # rugged_next_commit = rugged_repo.lookup(next_sha)
  # rugged_prev_commit_tree = rugged_prev_commit.tree
  # rugged_next_commit_tree = rugged_next_commit.tree
  # diff_bw_commit_trees = rugged_prev_commit_tree.diff(rugged_next_commit_tree)
  # PrintDiffBWCommitsRugged(diff_bw_commit_trees)
  # FIXME: Remember that the Rugged Gem doesn't provide stats for each diff
  # diff = Diff.new(prev_sha, next_sha, diff_bw_commit_trees.patch)

  # PrintDiffBWCommitsRubyGit(diff_bw_commits)

  diff = Diff.new(prev_sha, next_sha, diff_bw_commits)
  diff.generate_difffiles_and_stats
  diffs_array << diff
end

# ----------------------------------------------------------------------------------
# ------------------      CHECK FOR REVERTS       ----------------------------------
# ----------------------------------------------------------------------------------

stats_num_reverts = 0
difffile_name_num_reverts = 0
visited = {}
diffs_array.reverse_each do |diff|
  # For each diff starting from the latest, start comparison with the first
  diffs_array.each do |cmp_diff|
    next if diff == cmp_diff #No point looking at the same diff

    #next if diff
    # Checkpoint #1 - Number of difffiles should be equal
    next if diff.num_difffiles != cmp_diff.num_difffiles

    diff_pair = [diff, cmp_diff].sort!
    #puts diff_pair
    # If you have already visited this pair, don't work again on it
    next if visited[diff_pair] == true

    visited[diff_pair] = true
    #puts "visited[diff_pair] = " + visited[diff_pair].to_s
    # Checkpoint #2 - Compare stats if they are same
    puts "diff is = " + diff.to_s
    puts "cmp_diff is = " + cmp_diff.to_s
    puts "diff stats is = " + diff.stats.to_s
    puts "cmp_diff stats is = " + cmp_diff.stats.to_s
    raise "STATS NIL" unless diff.stats.nil? == false && cmp_diff.stats.nil? == false
    stats_match = CompareDiffStats(diff.stats, cmp_diff.stats)
    if stats_match == true
      stats_num_reverts = stats_num_reverts + 1
      puts "==================================   BEGIN ================================================"
      puts "--- STATS MATCH - Yes the stats match !! The revert commits are - "
      puts ">> The commit sha for this diff is - " + diff.next_commit_sha.to_s
      puts ">> The commit message for this diff is - " + rugged_repo.lookup("#{diff.next_commit_sha}").message
      puts ">> The reverted commit sha is - " + cmp_diff.next_commit_sha.to_s
      puts ">> The commit message for this diff is - " + rugged_repo.lookup("#{cmp_diff.next_commit_sha}").message
      puts "==================================   END  ================================================"
    end

    # Continue when the stats don't match
    # FIXME: Somehow I'm getting stats as nil for some commits.
    # So, mving forward to check directly based on contents
    # next if stats_match == false

    patch_match = CompareDiffPatch(diff, cmp_diff)
    if patch_match == true
      difffile_name_num_reverts = difffile_name_num_reverts + 1
      puts "==================================   BEGIN ================================================"
      puts "--- PATCH MATCH - Yes the patches match !! The revert commits are - "
      puts ">> The commit sha for this diff is - " + diff.next_commit_sha.to_s
      puts ">> The commit message for this diff is - " + rugged_repo.lookup("#{diff.next_commit_sha}").message
      puts ">> The reverted commit sha is - " + cmp_diff.next_commit_sha.to_s
      puts ">> The commit message for this diff is - " + rugged_repo.lookup("#{cmp_diff.next_commit_sha}").message
      puts "==================================   END  ================================================"
    end
  end
end
puts "The number of reverts based on stats are = " + stats_num_reverts.to_s
puts "The number of reverts based on difffile file names are = " + difffile_name_num_reverts.to_s

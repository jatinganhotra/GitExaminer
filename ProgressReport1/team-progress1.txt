Completed:
1. Analyzed number of reverts for 10 open-source projects by scanning the
commit messages for reverts. Script - logScanner.rb. Results - logAnalysis.csv
%age varies from 0.23% to 1.46%, with 2 projects more than 1%.
>> These percentages are based just on commit message not commit content, right?
Yes, these percentages are based just on commit messages. There were lot
of intricacies associated with properly handling commit history data and that's taking time.

2. Analyze how to store/mine the diff for every commit, to the finest granularity.
Tried out and experimented with multiple libraries aka gems(in Ruby) to see what
information can be extracted out. Class structure and different attributes for
each class are described on the project Github repo README.
>> Please add your GitHub repo link in these reports as otherwise I'll forget it.
Github Repo - https://github.com/silverSpoon/RevertFinder
and Project Website - http://jatinganhotra.com/RevertFinder/

3. Stored patch/changes for every difffile for every diff, along with other
relevant information. The diff history currently being modeled as linear-only.
4. Fixed an issue around representating the initial state i.e. the empty tree for
case when you perform `git revert InitialCommitID`
5. Performed experiments with git revert, found special cases which if handled
   should give better results.
>> I don't understand the overall result: did you compare how many commits
>> are inverse of some others based on *content* not *message*?
The above experiments are on various use-cases for git revert. e.g If
you do 'git revert CommitID' and the CommitID is in some other branch,
Git silently ignores it, but when the branch gets merged and you rerun
the git revert, then it works. 

Next steps for 2 weeks:
1. Analyze manual reverts in addition to auto-reverts
>> What do you mean by manual reverts?  One can run an auto-revert but manually
>> change the commit message.
No, a manual revert is essentially when you said 'git revert CommitID'
but when Git patched the changes, it resulted in some conflicts. In such
cases, the developer has to manually resolve these conflicts and then
commit the changes. The major difference between an auto-revert and a
manual revert would be that for an auto-revert, the diff now would not
be the exact opposite of diff when the Commit was made initially. This
is why, we are tracking every addition & deletion made to every file for
every diff, so that we can effeciently find such scenarios too.
If only message is changed, it's much easier to identify.

2. Extension to the above step - Analyze partial reverts where changes in the current
commit are reverse of changes to the file in a previous commit.
- Will add fine-grained details as I proceed on Github

>> One open-ended option to consider for future work would be to check how
>> often test selection gives the same result: even if a commit differs
>> based on both message and content, it could still be semantically inverse
>> up to the existing tests.
Yes, that's a great suggestion. We had something similar in mind, but the
other way round. We are planning to improve test selection preciseness,
once you know that the given commit is a revert. So, if you added any
extra testcases for that commit initially, you could simply take out
those testcases without running test selection tools. This would work
for auto-reverts only, though. This is missing in Ekstazi currently, as
we found out after discussion with Milos and Lamyaa in the beginning.

Last step(after everything is complete):
1. Store commit history as a directed graph, instead of a linear history to ensure
proper semantics of git reverts are handled. (in reference to pt. 5 above)
- Expect much better results after this, but can't say how much unless the above
infrastructure is complete.

>> UPDATE: Please provide answers to the above questions.
